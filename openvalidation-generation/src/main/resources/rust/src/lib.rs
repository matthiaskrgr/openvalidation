//@TODO move the following code into a separate file so that MyData is imported
// external.rs will be generated by OV-cli based on parameters that are passed to it.
// it describes the data model that the function contained in a Rule is run on
// use mock external.rs so that we can build

pub struct MyData {
    _name: String,
    _age: u32,
}

/*
pub struct MyData2 {
    amount: u8,
    location: Point,
}

pub struct Point {
    x: f32,
    y: f32,
}

pub struct MyData3 {
    amount: u8,
    location: Point,
    curve: Vec<Point>,
}

*/

#[allow(non_snake_case)]
pub mod HUML {
    // a function with static lifetime that operates on MyData and returns bool
    // this will be used to validate the data

    pub trait Callable: 'static + Fn(&crate::MyData) -> bool {}
    #[derive(Default, Clone)]
    pub struct HUMLFramework<'a> {
        // list of rules
        rules: Vec<ValidationRule<'a>>,
        // validation results?
        results: ValidationSummary,
    }

    impl<'a> HUMLFramework<'a> {
        pub fn new() -> Self {
            Self {
                rules: Vec::new(),
                results: ValidationSummary::new(),
            }
        }

        // add a rule to the HUML object
        pub fn add_rule<T: Callable>(
            &'a mut self,
            name: String,
            fields: Vec<String>,
            error: String,
            disabled: bool,
            function: &'a T,
            data: &'a crate::MyData,
        ) {
            let rule = ValidationRule::new(name, fields, error, disabled, function, data);
            self.rules.push(rule);
        }

        pub fn validate_rules(&mut self, _model: u32) {
            self.enabled_rules()
                .iter()
                .map(|rule| rule.validate())
                // save to the results field of the HUMLFramework. // this might be wrong
                

                // @TODO @FIXME I'm not sure if these should return bool or ValidationResult
                .for_each(|item| self.results.push(item));
                

        }

        pub fn get_rule_by_name(&'a self, name: String) -> Option<&'a ValidationRule> {
            // do we need to verify that rule name are uniqe?
            // should we return a list of rules with matching name?
            self.rules.iter().find(|rule| rule.name == name)
        }

        // returns a reference to the contained rules
        pub fn rules(&'a self) -> &'a Vec<ValidationRule<'a>> {
            &self.rules
        }

        // returns a reference to the results
        pub fn results(&'a self) -> &'a ValidationSummary {
            &self.results
        }

        // returns a list of only enabled rules
        pub fn enabled_rules(&'a self) -> Vec<&'a ValidationRule<'a>> {
            self.rules()
                .iter()
                .filter(|rule| !rule.disabled)
                .collect::<Vec<_>>()
        }
    } // impl HumlFrameWork

    // a validation rule
    #[derive(Clone)]
    pub struct ValidationRule<'a> {
        // most of the fields contain rule metadata
        name: String,
        // json keys
        fields: Vec<String>,
        // error returned in case the rule does not validate
        errormsg: String,
        // rules might be disabled
        disabled: bool,
        // a function that is run
        function: &'a dyn Callable,
        // the data that the rule is checked against
        data: &'a crate::MyData,
    }

    impl<'a> ValidationRule<'a> {
        pub fn new<T: Callable>(
            name: String,
            fields: Vec<String>,
            errormsg: String,
            disabled: bool,
            function: &'a T,
            data: &'a crate::MyData,
        ) -> Self {
            Self {
                name,
                fields,
                errormsg,
                disabled,
                function,
                data,
            }
        }

        pub fn name(&self) -> String {
            self.name.clone()
        }

        pub fn fields(&self) -> Vec<String> {
            self.fields.clone()
        }

        pub fn errormsg(&self) -> String {
            self.errormsg.clone()
        }

        pub fn is_disabled(&self) -> bool {
            self.disabled
        }

        pub fn data(&self) -> &crate::MyData {
            // we don't neccessarily know if the data impls Clone so borrow it
            &self.data
        }

        // hmm
        pub fn function(&self) -> &dyn Callable {
            self.function
        }

        pub fn validate(&self) -> bool {
            unimplemented!();
            self.function()(&self.data)
        }
    } // impl ValidationRUle

    // the result of a validation
    #[derive(Debug, Clone, PartialEq, Eq, Default)]
    pub struct ValidationError {
        field: String,
        error: String,
    }

    impl ValidationError {
        pub fn field(&self) -> String {
            self.field.clone()
        }

        pub fn error(&self) -> String {
            self.error.clone()
        }
    }

    // by using the newtype pattern we auto-inherit all vec methods, yay
    type ValidationSummary = Vec<Result<(), ValidationError>>;

    pub fn get_errors(summary: &ValidationSummary) -> Vec<ValidationError> {
        summary
            .iter()
            .cloned()
            .filter(|result| result.is_err())
            .map(|r| r.unwrap_err())
            .collect()
    }

    // a (in?)complete list of operators can be found here:
    // https://github.com/openvalidation/openvalidation/blob/09ae4e62c9e7d9efae89a307a7dd68f2db252649/openvalidation-common/src/main/java/io/openvalidation/common/ast/ASTComparisonOperator.java#L19
    // git grep "public enum AstComparisonOperator"

    // https://users.rust-lang.org/t/what-is-the-difference-between-eq-and-partialeq/15751/2

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn EQUALS<T: PartialEq>(left_operand: T, right_operand: T) -> bool {
        left_operand == right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn NOT_EQUALS<T: PartialEq>(left_operand: T, right_operand: T) -> bool {
        !EQUALS(left_operand, right_operand)
    }

    // partial ord so these work on floats too
    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn LESS_THAN<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand < right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn GREATER_THAN<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand > right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn LESS_OR_EQUALS<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand <= right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn GREATER_OR_EQUALS<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand >= right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is at least one of
        iterable.into_iter().any(|elm| elm == *item)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn NONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there none
        !iterable.into_iter().any(|elm| elm == *item)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn EXACTLY_ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is at least one of
        iterable.into_iter().filter(|elm| elm == item).count() == 1
    }

    // from python: https://github.com/openvalidation/openvalidation/pull/37/files

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn EXISTS<T>(item: Option<T>) -> bool {
        item.is_some()
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn NOT_EXISTS<T>(item: Option<T>) -> bool {
        item.is_none()
    }

    pub fn SUM_OF<T>(iterable: T) -> T::Item
    where
        T: IntoIterator,
        T::Item: std::iter::Sum,
    {
        iterable.into_iter().sum()
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn EMPTY<T>(vec: Vec<T>) -> bool {
        vec.is_empty()
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn NOT_EMPTY<T>(vec: Vec<T>) -> bool {
        !EMPTY(vec)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn FIRST<T>(iterable: &'_ T, number: usize) -> Vec<T::Item>
    where
        T: IntoIterator + Clone,
    {
        iterable
            .clone()
            .into_iter()
            .take(number)
            .collect::<Vec<_>>()
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn LAST<T>(iterable: &'_ T, number: usize) -> Vec<T::Item>
    where
        T: DoubleEndedIterator + ExactSizeIterator + Clone,
    {
        //@TODO can we avoid the double reverse somehow?
        iterable
            .clone()
            .rev() // reverse the list
            .take(number) // and only keep the the first N elemets
            .rev() // reverse back to original order
            .collect::<Vec<T::Item>>() // and return as Vec
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn equals() {
            // test numbers
            assert!(EQUALS(1, 1));
            assert!(EQUALS(-3, -3));
            assert!(!EQUALS(1, 2));

            // test vectors
            let mut v = Vec::new();
            v.push(1);
            v.push(3);
            assert!(EQUALS(vec![1, 3], v));
            assert!(EQUALS("hello", &"olleh".chars().rev().collect::<String>()));

            // test structs
            #[derive(Clone, PartialEq, Eq)]
            struct A {
                s: String,
                n: u8,
            }
            let a = A {
                s: "a".into(),
                n: 5,
            };
            assert!(EQUALS(a.clone(), a));

            let a = A {
                s: "a".into(),
                n: 5,
            };
            // modify b a bit to make sure they are not equal
            let mut b = a.clone();
            b.s = "oh no".into();
            b.n += 4;
            assert!(!EQUALS(a, b));
        }

        #[test]
        fn not_equals() {
            // test numbers
            assert!(!NOT_EQUALS(1, 1));
            assert!(!NOT_EQUALS(-3, -3));
            assert!(NOT_EQUALS(1, 2));

            // test vectors
            let mut v = Vec::new();
            v.push(1);
            v.push(3);
            assert!(!NOT_EQUALS(vec![1, 3], v));
            assert!(!NOT_EQUALS(
                "hello",
                &"olleh".chars().rev().collect::<String>()
            ));

            // test structs
            #[derive(Clone, PartialEq, Eq)]
            struct A {
                s: String,
                n: u8,
            }
            let a = A {
                s: "a".into(),
                n: 5,
            };
            assert!(!NOT_EQUALS(a.clone(), a));

            let a = A {
                s: "a".into(),
                n: 5,
            };
            // modify b a bit to make sure they are not equal
            let mut b = a.clone();
            b.s = "oh no".into();
            b.n += 4;
            assert!(NOT_EQUALS(a, b));
        }

        #[test]
        fn less_than() {
            // test numbers
            assert!(LESS_THAN(1, 3));
            assert!(LESS_THAN(0, 1));
            assert!(!LESS_THAN(0, 0));
            assert!(LESS_THAN(-1, 0));
            assert!(!LESS_THAN(std::i32::MAX, 3));
            assert!(LESS_THAN(99, std::i32::MAX));
            assert!(!LESS_THAN(std::i32::MAX, std::i32::MAX));
            assert!(LESS_THAN(std::u8::MIN, std::u8::MAX));
            assert!(LESS_THAN(std::u8::MIN, 1));
            assert!(!LESS_THAN(std::u8::MIN, 0));
            assert!(!LESS_THAN(std::u8::MAX, 255));
            assert!(LESS_THAN(std::u8::MAX - 1, 255));
            assert!(LESS_THAN(0.1, 10.0));
            assert!(LESS_THAN(0.00000001, 0.0001));
            assert!(!LESS_THAN(0.001, 0.001));
            assert!(LESS_THAN(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn greater_than() {
            // test numbers
            assert!(!GREATER_THAN(1, 3));
            assert!(!GREATER_THAN(0, 1));
            assert!(!GREATER_THAN(0, 0));
            assert!(!GREATER_THAN(-1, 0));
            assert!(GREATER_THAN(std::i32::MAX, 3));
            assert!(!GREATER_THAN(99, std::i32::MAX));
            assert!(!GREATER_THAN(std::i32::MAX, std::i32::MAX));
            assert!(!GREATER_THAN(std::u8::MIN, std::u8::MAX));
            assert!(!GREATER_THAN(std::u8::MIN, 1));
            assert!(!GREATER_THAN(std::u8::MIN, 0));
            assert!(!GREATER_THAN(std::u8::MAX, 255)); // equals
            assert!(!GREATER_THAN(std::u8::MAX - 1, 255));
            assert!(!GREATER_THAN(0.1, 10.0));
            assert!(!GREATER_THAN(0.00000001, 0.0001));
            assert!(!GREATER_THAN(0.001, 0.001));
            assert!(!GREATER_THAN(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn less_or_equals() {
            // test numbers
            assert!(LESS_OR_EQUALS(1, 3));
            assert!(LESS_OR_EQUALS(0, 1));
            assert!(LESS_OR_EQUALS(0, 0));
            assert!(LESS_OR_EQUALS(-1, 0));
            assert!(!LESS_OR_EQUALS(std::i32::MAX, 3));
            assert!(LESS_OR_EQUALS(99, std::i32::MAX));
            assert!(LESS_OR_EQUALS(std::i32::MAX, std::i32::MAX));
            assert!(LESS_OR_EQUALS(std::u8::MIN, std::u8::MAX));
            assert!(LESS_OR_EQUALS(std::u8::MIN, 1));
            assert!(LESS_OR_EQUALS(std::u8::MIN, 0));
            assert!(LESS_OR_EQUALS(std::u8::MAX, 255));
            assert!(LESS_OR_EQUALS(std::u8::MAX - 1, 255));
            assert!(LESS_OR_EQUALS(0.1, 10.0));
            assert!(LESS_OR_EQUALS(0.00000001, 0.0001));
            assert!(LESS_OR_EQUALS(0.001, 0.001));
            assert!(!LESS_OR_EQUALS(0.1, 0.0));
            assert!(LESS_OR_EQUALS(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn greater_or_equals() {
            // test numbers
            assert!(!GREATER_OR_EQUALS(1, 3));
            assert!(!GREATER_OR_EQUALS(0, 1));
            assert!(GREATER_OR_EQUALS(0, 0));
            assert!(!GREATER_OR_EQUALS(-1, 0));
            assert!(GREATER_OR_EQUALS(std::i32::MAX, 3));
            assert!(!GREATER_OR_EQUALS(99, std::i32::MAX));
            assert!(GREATER_OR_EQUALS(std::i32::MAX, std::i32::MAX));
            assert!(!GREATER_OR_EQUALS(std::u8::MIN, std::u8::MAX));
            assert!(!GREATER_OR_EQUALS(std::u8::MIN, 1));
            assert!(GREATER_OR_EQUALS(std::u8::MIN, 0));
            assert!(GREATER_OR_EQUALS(std::u8::MAX, 255)); // equals
            assert!(!GREATER_OR_EQUALS(std::u8::MAX - 1, 255));
            assert!(!GREATER_OR_EQUALS(0.1, 10.0));
            assert!(!GREATER_OR_EQUALS(0.00000001, 0.0001));
            assert!(GREATER_OR_EQUALS(0.001, 0.001));
            assert!(!GREATER_OR_EQUALS(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn one_of() {
            // empty vec
            assert!(!ONE_OF(vec![], &()));
            assert!(ONE_OF(vec![1], &(1)));
            assert!(!ONE_OF(vec![], &(1)));
            assert!(!ONE_OF(vec![1], &(0)));

            // vec from range
            (0..=1000_i32)
                .for_each(|x: i32| assert!(ONE_OF((0..=1000_i32).collect::<Vec<i32>>(), &x)));

            (0..=100_i32)
                .for_each(|x: i32| assert!(!ONE_OF((101..=1000_i32).collect::<Vec<i32>>(), &x)));

            assert!(ONE_OF(vec![1, 2, 3, 4, 5], &(1)));
            assert!(ONE_OF(vec!["a", "c", "f", "1", "z"], &("z")));
            assert!(ONE_OF(vec!["hello", "é", "this", "", "isatest"], &("")));
            assert!(!ONE_OF(vec!["hello", "é", "this", "", "isatest"], &("ö")));
            assert!(!ONE_OF(
                vec!["hello", "é", "this", "", "isatest"],
                &("veryverylong")
            ));
            assert!(ONE_OF(vec![1, 1, 1, 1, 1], &(1)));
            assert!(!ONE_OF(vec![1, 1, 1, 1, 1], &(2)));

            // nested vecs/structs
            assert!(ONE_OF(
                vec![
                    vec![1, 2],
                    vec![2, 3],
                    vec![],
                    vec![9, 4, 234, 1],
                    vec![4, 2]
                ],
                &(vec![4, 2])
            ));
        }

        #[test]
        fn exists() {
            assert!(EXISTS(Some(())));
            let none: Option<()> = None;
            assert!(!EXISTS(none));
            assert!(EXISTS(Some("hello")));
            assert!(EXISTS(Some(Some(vec![()]))));
            assert!(EXISTS(Some(none)));
        }

        #[test]
        fn not_exists() {
            assert!(!NOT_EXISTS(Some(())));
            let none: Option<()> = None;
            assert!(NOT_EXISTS(none));
            assert!(!NOT_EXISTS(Some("hello")));
            assert!(!NOT_EXISTS(Some(Some(vec![()]))));
            assert!(!NOT_EXISTS(Some(none)));
        }

        #[test]
        fn empty() {
            assert!(EMPTY(Vec::<()>::new()));
            assert!(!EMPTY(vec![0]));
            assert!(!EMPTY(vec![1, 2, 3]));
            assert!(!EMPTY(vec![vec![()]]));
        }

        #[test]
        fn not_empty() {
            assert!(!NOT_EMPTY(Vec::<()>::new()));
            assert!(NOT_EMPTY(vec![0]));
            assert!(NOT_EMPTY(vec![1, 2, 3]));
            assert!(NOT_EMPTY(vec![vec![()]]));
        }

        #[test]
        fn first() {
            // vec
            let v = vec![1, 2, 3, 4];
            assert!(FIRST(&v, 0).is_empty());
            assert_eq!(FIRST(&v, 1), vec![1]);
            assert_eq!(FIRST(&v, 2), vec![1, 2]);
            assert_eq!(FIRST(&v, 3), vec![1, 2, 3]);
            assert_eq!(FIRST(&v, 4), vec![1, 2, 3, 4]);
            assert_eq!(FIRST(&v, 5), vec![1, 2, 3, 4]);
            // empty vec
            assert_eq!(FIRST(&Vec::<u8>::new(), 0), vec![]);
            assert_eq!(FIRST(&Vec::<u8>::new(), 1000), vec![]);
            // slice // can we get these to work somehow?
            //assert_eq!(FIRST(&vec![1,2,3].as_slice(), 5), &vec![1, 2, 3].as_slice());
            //assert_eq!(FIRST(&vec![1,2,3][..], 5), vec![1, 2, 3][..]);
            // string
            //let s = String::from("Hello World");
            //assert_eq!(FIRST(&s.chars(), 5), "Hello".chars().collect::<Vec<_>>());
        }
    }
}
