//@TODO move the following code into a separate file so that MyData is imported
// external.rs will be generated by OV-cli based on parameters that are passed to it.
// it describes the data model that the function contained in a Rule is run on
// use mock external.rs so that we can build

// deny unsafe code
#![deny(unsafe_code)]


pub struct MyData {
    age: u32,
    name: String,
}

/*
pub struct MyData2 {
    amount: u8,
    location: Point,
}

pub struct Point {
    x: f32,
    y: f32,
}

pub struct MyData3 {
    amount: u8,
    location: Point,
    curve: Vec<Point>,
}

*/

#[allow(non_snake_case)]
pub mod HUML {
    // a function with static lifetime that operates on MyData and returns bool
    // this will be used to validate the data

    // Die Methode (callable), die zu einer rule gehört gibt true zurück
    // wenn gemäß dieser Regel ein Fehler vorliegt
    // und false otherwise

    //pub trait Callable: for<'r> Fn(&'r crate::MyData) -> bool {}

    //  pub trait Callable: Fn(&crate::MyData)-> bool {}
    #[derive(Default, Clone)]
    pub struct HUMLFramework<'a> {
        // list of rules
        rules: Vec<ValidationRule<'a>>,
    }

    impl<'a> HUMLFramework<'a> {
        pub fn new() -> Self {
            Self { rules: Vec::new() }
        }

        // add a rule to the HUML object
        pub fn append_rule<T: Fn(&crate::MyData) -> bool>(
            &'a mut self,
            name: String, // @TODO use AsRef<str> here
            fields: Vec<String>,
            error: String,
            disabled: bool,
            function: &'a T,
            data: &'a crate::MyData,
        ) {
            let rule = ValidationRule::new(name, fields, error, disabled, function, data);
            self.push_rule(rule);
        }

        // takes rule object and pushes it into huml object
        pub fn push_rule(&'a mut self, rule: ValidationRule<'a>) {
            self.rules.push(rule);
        }

        // SILAS:
        /// Die validate Methode gibt ein Objekt zurück, dass Informationen über alle gefundenen Fehler enthält.
        /// // Vec<Result<(),ValidationError>>
        // Methodennamen und -signaturen, sowie Datenstrukturen (z.B. das Rückgabeobjekt der validate Methode) sollen sich in allen Sprachen so exakt wie möglich entsprechen.

        pub fn validate(&mut self) -> ValidationSummary {
            //- In einem validate-Aufruf wird in einer Schleife die function der
            //  Regel auf Daten angewendet und gegebenenfalls die
            //  Fehlernachricht etc. dem Validierungsergebnis hinzugefügt.
            // gefundener Fehler heißt die function gibt true zurück

            let mut summary = ValidationSummary::new();

            for rule in self.enabled_rules().iter() {
                // apply the rule to the data
                if rule.validate() {
                    // gefundener fehler heißt die funktion gibt true zurück

                    let error = rule.errormsg.clone();
                    let fields = rule.fields.clone();
                    let val_error = ValidationError::new(error, fields);
                    // add both of them to the summary
                    summary.push(Err(val_error));
                } else {
                    // do  nothing
                }
            }

            summary
        }

        pub fn get_rule_by_name(&'a self, name: String) -> Option<&'a ValidationRule> {
            // do we need to verify that rule name are uniqe?
            // should we return a list of rules with matching name?
            self.rules.iter().find(|rule| rule.name == name)
        }

        // returns a reference to the contained rules
        pub fn rules(&'a self) -> &'a Vec<ValidationRule<'a>> {
            &self.rules
        }

        // returns a list of only enabled rules
        pub fn enabled_rules(&'a self) -> Vec<&'a ValidationRule<'a>> {
            self.rules()
                .iter()
                .filter(|rule| !rule.disabled)
                .collect::<Vec<_>>()
        }
    } // impl HumlFrameWork

    // a validation rule
    #[derive(Clone)]
    pub struct ValidationRule<'a> {
        // most of the fields contain rule metadata
        name: String,
        // json keys
        fields: Vec<String>,
        // error returned in case the rule does not validate
        errormsg: String,
        // rules might be disabled
        disabled: bool,
        // a function t
        // hat is run
        function: &'a dyn Fn(&crate::MyData) -> bool,
        // the data that the rule is checked against
        data: &'a crate::MyData,
    }

    impl<'a> ValidationRule<'a> {
        pub fn new<T: Fn(&crate::MyData) -> bool>(
            name: String,
            fields: Vec<String>,
            errormsg: String,
            disabled: bool,
            function: &'a T,
            data: &'a crate::MyData,
        ) -> Self {
            Self {
                name,
                fields,
                errormsg,
                disabled,
                function,
                data,
            }
        }

        pub fn name(&self) -> String {
            self.name.clone()
        }

        pub fn fields(&self) -> Vec<String> {
            self.fields.clone()
        }

        pub fn errormsg(&self) -> String {
            self.errormsg.clone()
        }

        pub fn is_disabled(&self) -> bool {
            self.disabled
        }

        pub fn data(&self) -> &crate::MyData {
            // we don't neccessarily know if the data impls Clone so borrow it
            &self.data
        }

        // hmm
        pub fn function(&self) -> &dyn Fn(&crate::MyData) -> bool {
            self.function
        }

        pub fn validate(&self) -> bool {
            self.function()(&self.data)
        }
    } // impl ValidationRule

    #[derive(Debug, Clone, PartialEq, Eq, Default)]
    pub struct ValidationResult {
        errors: Option<Vec<ValidationError>>,
        fields: Vec<String>,
    }

    impl ValidationResult {
        pub fn new(errors: Vec<ValidationError>, fields: Vec<String>) -> Self {
            Self {
                errors: Some(errors),
                fields,
            }
        }

        // add a single item
        pub fn append(&mut self, error: ValidationError, field: String) {
            match &mut self.errors {
                Some(v) => v.push(error),
                None => self.errors = Some(vec![error]),
            }

            self.fields.push(field);
        }

        // extend self by a vector of item
        pub fn extend(&mut self, errors: Vec<ValidationError>, fields: Vec<String>) {
            match &mut self.errors {
                Some(v) => v.extend(errors),
                None => self.errors = Some(errors),
            }

            self.fields.extend(fields);
        }
    }

    // the result of a validation
    #[derive(Debug, Clone, PartialEq, Eq, Default)]
    pub struct ValidationError {
        error: String,
        fields: Vec<String>,
    }

    impl ValidationError {
        pub fn new(error: String, fields: Vec<String>) -> Self {
            Self { error, fields }
        }

        pub fn fields(&self) -> Vec<String> {
            self.fields.clone()
        }

        pub fn error(&self) -> String {
            self.error.clone()
        }
    }

    // by using the newtype pattern we auto-inherit all vec methods, yay
    type ValidationSummary = Vec<Result<(), ValidationError>>;

    pub fn get_errors(summary: &ValidationSummary) -> Vec<ValidationError> {
        summary
            .iter()
            .cloned()
            .filter(|result| result.is_err())
            .map(|r| r.unwrap_err())
            .collect()
    }

    // a (in?)complete list of operators can be found here:
    // https://github.com/openvalidation/openvalidation/blob/09ae4e62c9e7d9efae89a307a7dd68f2db252649/openvalidation-common/src/main/java/io/openvalidation/common/ast/ASTComparisonOperator.java#L19
    // git grep "public enum AstComparisonOperator"

    // https://users.rust-lang.org/t/what-is-the-difference-between-eq-and-partialeq/15751/2

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn EQUALS<T: PartialEq>(left_operand: T, right_operand: T) -> bool {
        left_operand == right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn NOT_EQUALS<T: PartialEq>(left_operand: T, right_operand: T) -> bool {
        !EQUALS(left_operand, right_operand)
    }

    // partial ord so these work on floats too
    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn LESS_THAN<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand < right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn GREATER_THAN<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand > right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn LESS_OR_EQUALS<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand <= right_operand
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn GREATER_OR_EQUALS<T: PartialOrd>(left_operand: T, right_operand: T) -> bool {
        left_operand >= right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is at least one of
        iterable.into_iter().any(|elm| elm == *item)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn NONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there none
        !iterable.into_iter().any(|elm| elm == *item)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn EXACTLY_ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is at least one of
        iterable.into_iter().filter(|elm| elm == item).count() == 1
    }

    // from python: https://github.com/openvalidation/openvalidation/pull/37/files

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn EXISTS<T>(item: Option<T>) -> bool {
        item.is_some()
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn NOT_EXISTS<T>(item: Option<T>) -> bool {
        item.is_none()
    }

    pub fn SUM_OF<T>(iterable: T) -> T::Item
    where
        T: IntoIterator,
        T::Item: std::iter::Sum,
    {
        iterable.into_iter().sum()
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn EMPTY<T>(vec: Vec<T>) -> bool {
        vec.is_empty()
    }

    #[allow(non_snake_case)]
    #[inline(always)]
    pub fn NOT_EMPTY<T>(vec: Vec<T>) -> bool {
        !EMPTY(vec)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn FIRST<T>(iterable: &'_ T, number: usize) -> Vec<T::Item>
    where
        T: IntoIterator + Clone,
    {
        iterable
            .clone()
            .into_iter()
            .take(number)
            .collect::<Vec<_>>()
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn LAST<T>(iterable: &'_ T, number: usize) -> Vec<T::Item>
    where
        T: DoubleEndedIterator + ExactSizeIterator + Clone,
    {
        //@TODO can we avoid the double reverse somehow?
        iterable
            .clone()
            .rev() // reverse the list
            .take(number) // and only keep the the first N elemets
            .rev() // reverse back to original order
            .collect::<Vec<T::Item>>() // and return as Vec
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_huml() {
            use crate::MyData;

            let schema: MyData = MyData {
                age: 17,
                name: String::from("Hans"),
            };

            let mut huml: HUMLFramework = HUMLFramework::new();

            let rule = ValidationRule::new(
                String::from("rule1"),
                vec![String::from("field 1")],
                String::from("person is not old enough!"),
                false,
                &|x: &crate::MyData| x.age > 18 && x.name == "Hans",
                &schema,
            );

            huml.push_rule(rule);
            /*
            let rule_2 = ValidationRule::new(
                String::from("rule1"),
                vec![String::from("field 1")],
                String::from("person is not old enough!"),
                false,
                &|x: &crate::MyData| x.age < 7 && x.name == "Franz",
                &schema,
            );

            huml.push_rule(rule_2);

            */
            // @TODO  Cannot borrow 'huml' as mutable more than once at a time!!!
        }

        #[test]
        fn equals() {
            // test numbers
            assert!(EQUALS(1, 1));
            assert!(EQUALS(-3, -3));
            assert!(!EQUALS(1, 2));

            // test vectors
            let mut v = Vec::new();
            v.push(1);
            v.push(3);
            assert!(EQUALS(vec![1, 3], v));
            assert!(EQUALS("hello", &"olleh".chars().rev().collect::<String>()));

            // test structs
            #[derive(Clone, PartialEq, Eq)]
            struct A {
                s: String,
                n: u8,
            }
            let a = A {
                s: "a".into(),
                n: 5,
            };
            assert!(EQUALS(a.clone(), a));

            let a = A {
                s: "a".into(),
                n: 5,
            };
            // modify b a bit to make sure they are not equal
            let mut b = a.clone();
            b.s = "oh no".into();
            b.n += 4;
            assert!(!EQUALS(a, b));
        }

        #[test]
        fn not_equals() {
            // test numbers
            assert!(!NOT_EQUALS(1, 1));
            assert!(!NOT_EQUALS(-3, -3));
            assert!(NOT_EQUALS(1, 2));

            // test vectors
            let mut v = Vec::new();
            v.push(1);
            v.push(3);
            assert!(!NOT_EQUALS(vec![1, 3], v));
            assert!(!NOT_EQUALS(
                "hello",
                &"olleh".chars().rev().collect::<String>()
            ));

            // test structs
            #[derive(Clone, PartialEq, Eq)]
            struct A {
                s: String,
                n: u8,
            }
            let a = A {
                s: "a".into(),
                n: 5,
            };
            assert!(!NOT_EQUALS(a.clone(), a));

            let a = A {
                s: "a".into(),
                n: 5,
            };
            // modify b a bit to make sure they are not equal
            let mut b = a.clone();
            b.s = "oh no".into();
            b.n += 4;
            assert!(NOT_EQUALS(a, b));
        }

        #[test]
        fn less_than() {
            // test numbers
            assert!(LESS_THAN(1, 3));
            assert!(LESS_THAN(0, 1));
            assert!(!LESS_THAN(0, 0));
            assert!(LESS_THAN(-1, 0));
            assert!(!LESS_THAN(std::i32::MAX, 3));
            assert!(LESS_THAN(99, std::i32::MAX));
            assert!(!LESS_THAN(std::i32::MAX, std::i32::MAX));
            assert!(LESS_THAN(std::u8::MIN, std::u8::MAX));
            assert!(LESS_THAN(std::u8::MIN, 1));
            assert!(!LESS_THAN(std::u8::MIN, 0));
            assert!(!LESS_THAN(std::u8::MAX, 255));
            assert!(LESS_THAN(std::u8::MAX - 1, 255));
            assert!(LESS_THAN(0.1, 10.0));
            assert!(LESS_THAN(0.00000001, 0.0001));
            assert!(!LESS_THAN(0.001, 0.001));
            assert!(LESS_THAN(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn greater_than() {
            // test numbers
            assert!(!GREATER_THAN(1, 3));
            assert!(!GREATER_THAN(0, 1));
            assert!(!GREATER_THAN(0, 0));
            assert!(!GREATER_THAN(-1, 0));
            assert!(GREATER_THAN(std::i32::MAX, 3));
            assert!(!GREATER_THAN(99, std::i32::MAX));
            assert!(!GREATER_THAN(std::i32::MAX, std::i32::MAX));
            assert!(!GREATER_THAN(std::u8::MIN, std::u8::MAX));
            assert!(!GREATER_THAN(std::u8::MIN, 1));
            assert!(!GREATER_THAN(std::u8::MIN, 0));
            assert!(!GREATER_THAN(std::u8::MAX, 255)); // equals
            assert!(!GREATER_THAN(std::u8::MAX - 1, 255));
            assert!(!GREATER_THAN(0.1, 10.0));
            assert!(!GREATER_THAN(0.00000001, 0.0001));
            assert!(!GREATER_THAN(0.001, 0.001));
            assert!(!GREATER_THAN(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn less_or_equals() {
            // test numbers
            assert!(LESS_OR_EQUALS(1, 3));
            assert!(LESS_OR_EQUALS(0, 1));
            assert!(LESS_OR_EQUALS(0, 0));
            assert!(LESS_OR_EQUALS(-1, 0));
            assert!(!LESS_OR_EQUALS(std::i32::MAX, 3));
            assert!(LESS_OR_EQUALS(99, std::i32::MAX));
            assert!(LESS_OR_EQUALS(std::i32::MAX, std::i32::MAX));
            assert!(LESS_OR_EQUALS(std::u8::MIN, std::u8::MAX));
            assert!(LESS_OR_EQUALS(std::u8::MIN, 1));
            assert!(LESS_OR_EQUALS(std::u8::MIN, 0));
            assert!(LESS_OR_EQUALS(std::u8::MAX, 255));
            assert!(LESS_OR_EQUALS(std::u8::MAX - 1, 255));
            assert!(LESS_OR_EQUALS(0.1, 10.0));
            assert!(LESS_OR_EQUALS(0.00000001, 0.0001));
            assert!(LESS_OR_EQUALS(0.001, 0.001));
            assert!(!LESS_OR_EQUALS(0.1, 0.0));
            assert!(LESS_OR_EQUALS(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn greater_or_equals() {
            // test numbers
            assert!(!GREATER_OR_EQUALS(1, 3));
            assert!(!GREATER_OR_EQUALS(0, 1));
            assert!(GREATER_OR_EQUALS(0, 0));
            assert!(!GREATER_OR_EQUALS(-1, 0));
            assert!(GREATER_OR_EQUALS(std::i32::MAX, 3));
            assert!(!GREATER_OR_EQUALS(99, std::i32::MAX));
            assert!(GREATER_OR_EQUALS(std::i32::MAX, std::i32::MAX));
            assert!(!GREATER_OR_EQUALS(std::u8::MIN, std::u8::MAX));
            assert!(!GREATER_OR_EQUALS(std::u8::MIN, 1));
            assert!(GREATER_OR_EQUALS(std::u8::MIN, 0));
            assert!(GREATER_OR_EQUALS(std::u8::MAX, 255)); // equals
            assert!(!GREATER_OR_EQUALS(std::u8::MAX - 1, 255));
            assert!(!GREATER_OR_EQUALS(0.1, 10.0));
            assert!(!GREATER_OR_EQUALS(0.00000001, 0.0001));
            assert!(GREATER_OR_EQUALS(0.001, 0.001));
            assert!(!GREATER_OR_EQUALS(std::u128::MIN, std::u128::MAX));
        }

        #[test]
        fn one_of() {
            // empty vec
            assert!(!ONE_OF(vec![], &()));
            assert!(ONE_OF(vec![1], &(1)));
            assert!(!ONE_OF(vec![], &(1)));
            assert!(!ONE_OF(vec![1], &(0)));

            // vec from range
            (0..=1000_i32)
                .for_each(|x: i32| assert!(ONE_OF((0..=1000_i32).collect::<Vec<i32>>(), &x)));

            (0..=100_i32)
                .for_each(|x: i32| assert!(!ONE_OF((101..=1000_i32).collect::<Vec<i32>>(), &x)));

            assert!(ONE_OF(vec![1, 2, 3, 4, 5], &(1)));
            assert!(ONE_OF(vec!["a", "c", "f", "1", "z"], &("z")));
            assert!(ONE_OF(vec!["hello", "é", "this", "", "isatest"], &("")));
            assert!(!ONE_OF(vec!["hello", "é", "this", "", "isatest"], &("ö")));
            assert!(!ONE_OF(
                vec!["hello", "é", "this", "", "isatest"],
                &("veryverylong")
            ));
            assert!(ONE_OF(vec![1, 1, 1, 1, 1], &(1)));
            assert!(!ONE_OF(vec![1, 1, 1, 1, 1], &(2)));

            // nested vecs/structs
            assert!(ONE_OF(
                vec![
                    vec![1, 2],
                    vec![2, 3],
                    vec![],
                    vec![9, 4, 234, 1],
                    vec![4, 2]
                ],
                &(vec![4, 2])
            ));
        }

        #[test]
        fn exists() {
            assert!(EXISTS(Some(())));
            let none: Option<()> = None;
            assert!(!EXISTS(none));
            assert!(EXISTS(Some("hello")));
            assert!(EXISTS(Some(Some(vec![()]))));
            assert!(EXISTS(Some(none)));
        }

        #[test]
        fn not_exists() {
            assert!(!NOT_EXISTS(Some(())));
            let none: Option<()> = None;
            assert!(NOT_EXISTS(none));
            assert!(!NOT_EXISTS(Some("hello")));
            assert!(!NOT_EXISTS(Some(Some(vec![()]))));
            assert!(!NOT_EXISTS(Some(none)));
        }

        #[test]
        fn empty() {
            assert!(EMPTY(Vec::<()>::new()));
            assert!(!EMPTY(vec![0]));
            assert!(!EMPTY(vec![1, 2, 3]));
            assert!(!EMPTY(vec![vec![()]]));
        }

        #[test]
        fn not_empty() {
            assert!(!NOT_EMPTY(Vec::<()>::new()));
            assert!(NOT_EMPTY(vec![0]));
            assert!(NOT_EMPTY(vec![1, 2, 3]));
            assert!(NOT_EMPTY(vec![vec![()]]));
        }

        #[test]
        fn first() {
            // vec
            let v = vec![1, 2, 3, 4];
            assert!(FIRST(&v, 0).is_empty());
            assert_eq!(FIRST(&v, 1), vec![1]);
            assert_eq!(FIRST(&v, 2), vec![1, 2]);
            assert_eq!(FIRST(&v, 3), vec![1, 2, 3]);
            assert_eq!(FIRST(&v, 4), vec![1, 2, 3, 4]);
            assert_eq!(FIRST(&v, 5), vec![1, 2, 3, 4]);
            // empty vec
            assert_eq!(FIRST(&Vec::<u8>::new(), 0), vec![]);
            assert_eq!(FIRST(&Vec::<u8>::new(), 1000), vec![]);
            // slice // can we get these to work somehow?
            //assert_eq!(FIRST(&vec![1,2,3].as_slice(), 5), &vec![1, 2, 3].as_slice());
            //assert_eq!(FIRST(&vec![1,2,3][..], 5), vec![1, 2, 3][..]);
            // string
            //let s = String::from("Hello World");
            //assert_eq!(FIRST(&s.chars(), 5), "Hello".chars().collect::<Vec<_>>());
        }
    }
}
